{"version":3,"file":"tree-fc0e156a.js","sources":["../../src/utils/tree.ts"],"sourcesContent":["interface TreeHelperConfig {\n  id: string;\n  children: string;\n  pid: string;\n}\n\nconst DEFAULT_CONFIG: TreeHelperConfig = {\n  id: 'id',\n  children: 'children',\n  pid: 'pid',\n};\nexport const defaultProps = {\n  children: 'children',\n  label: 'name',\n  value: 'id',\n  isLeaf: 'leaf',\n};\n\nconst getConfig = (config: Partial<TreeHelperConfig>) => Object.assign({}, DEFAULT_CONFIG, config);\n\n// tree from list\nexport const listToTree = <T = any>(list: any[], config: Partial<TreeHelperConfig> = {}): T[] => {\n  const conf = getConfig(config) as TreeHelperConfig;\n  const nodeMap = new Map();\n  const result: T[] = [];\n  const { id, children, pid } = conf;\n\n  for (const node of list) {\n    node[children] = node[children] || [];\n    nodeMap.set(node[id], node);\n  }\n  for (const node of list) {\n    const parent = nodeMap.get(node[pid]);\n    (parent ? parent.children : result).push(node);\n  }\n  return result;\n};\n\nexport const treeToList = <T = any>(tree: any, config: Partial<TreeHelperConfig> = {}): T => {\n  config = getConfig(config);\n  const { children } = config;\n  const result: any = [...tree];\n  for (let i = 0; i < result.length; i++) {\n    if (!result[i][children!]) continue;\n    result.splice(i + 1, 0, ...result[i][children!]);\n  }\n  return result;\n};\n\nexport const findNode = <T = any>(\n  tree: any,\n  func: Fn,\n  config: Partial<TreeHelperConfig> = {},\n): T | null => {\n  config = getConfig(config);\n  const { children } = config;\n  const list = [...tree];\n  for (const node of list) {\n    if (func(node)) return node;\n    node[children!] && list.push(...node[children!]);\n  }\n  return null;\n};\n\nexport const findNodeAll = <T = any>(\n  tree: any,\n  func: Fn,\n  config: Partial<TreeHelperConfig> = {},\n): T[] => {\n  config = getConfig(config);\n  const { children } = config;\n  const list = [...tree];\n  const result: T[] = [];\n  for (const node of list) {\n    func(node) && result.push(node);\n    node[children!] && list.push(...node[children!]);\n  }\n  return result;\n};\n\nexport const findPath = <T = any>(\n  tree: any,\n  func: Fn,\n  config: Partial<TreeHelperConfig> = {},\n): T | T[] | null => {\n  config = getConfig(config);\n  const path: T[] = [];\n  const list = [...tree];\n  const visitedSet = new Set();\n  const { children } = config;\n  while (list.length) {\n    const node = list[0];\n    if (visitedSet.has(node)) {\n      path.pop();\n      list.shift();\n    } else {\n      visitedSet.add(node);\n      node[children!] && list.unshift(...node[children!]);\n      path.push(node);\n      if (func(node)) {\n        return path;\n      }\n    }\n  }\n  return null;\n};\n\nexport const findPathAll = (tree: any, func: Fn, config: Partial<TreeHelperConfig> = {}) => {\n  config = getConfig(config);\n  const path: any[] = [];\n  const list = [...tree];\n  const result: any[] = [];\n  const visitedSet = new Set(),\n    { children } = config;\n  while (list.length) {\n    const node = list[0];\n    if (visitedSet.has(node)) {\n      path.pop();\n      list.shift();\n    } else {\n      visitedSet.add(node);\n      node[children!] && list.unshift(...node[children!]);\n      path.push(node);\n      func(node) && result.push([...path]);\n    }\n  }\n  return result;\n};\n\nexport const filter = <T = any>(\n  tree: T[],\n  func: (n: T) => boolean,\n  config: Partial<TreeHelperConfig> = {},\n): T[] => {\n  config = getConfig(config);\n  const children = config.children as string;\n\n  function listFilter(list: T[]) {\n    return list\n      .map((node: any) => ({ ...node }))\n      .filter((node) => {\n        node[children] = node[children] && listFilter(node[children]);\n        return func(node) || (node[children] && node[children].length);\n      });\n  }\n\n  return listFilter(tree);\n};\n\nexport const forEach = <T = any>(\n  tree: T[],\n  func: (n: T) => any,\n  config: Partial<TreeHelperConfig> = {},\n): void => {\n  config = getConfig(config);\n  const list: any[] = [...tree];\n  const { children } = config;\n  for (let i = 0; i < list.length; i++) {\n    // func 返回true就终止遍历，避免大量节点场景下无意义循环，引起浏览器卡顿\n    if (func(list[i])) {\n      return;\n    }\n    children && list[i][children] && list.splice(i + 1, 0, ...list[i][children]);\n  }\n};\n\n/**\n * @description: Extract tree specified structure\n */\nexport const treeMap = <T = any>(\n  treeData: T[],\n  opt: { children?: string; conversion: Fn },\n): T[] => {\n  return treeData.map((item) => treeMapEach(item, opt));\n};\n\n/**\n * @description: Extract tree specified structure\n */\nexport const treeMapEach = (\n  data: any,\n  { children = 'children', conversion }: { children?: string; conversion: Fn },\n) => {\n  const haveChildren = Array.isArray(data[children]) && data[children].length > 0;\n  const conversionData = conversion(data) || {};\n  if (haveChildren) {\n    return {\n      ...conversionData,\n      [children]: data[children].map((i: number) =>\n        treeMapEach(i, {\n          children,\n          conversion,\n        }),\n      ),\n    };\n  } else {\n    return {\n      ...conversionData,\n    };\n  }\n};\n\n/**\n * 递归遍历树结构\n * @param treeDatas 树\n * @param callBack 回调\n * @param parentNode 父节点\n */\nexport const eachTree = (treeDatas: any[], callBack: Fn, parentNode = {}) => {\n  treeDatas.forEach((element) => {\n    const newNode = callBack(element, parentNode) || element;\n    if (element.children) {\n      eachTree(element.children, callBack, newNode);\n    }\n  });\n};\n\n/**\n * 构造树型结构数据\n * @param {*} data 数据源\n * @param {*} id id字段 默认 'id'\n * @param {*} parentId 父节点字段 默认 'parentId'\n * @param {*} children 孩子节点字段 默认 'children'\n */\nexport const handleTree = (data: any[], id?: string, parentId?: string, children?: string) => {\n  if (!Array.isArray(data)) {\n    console.warn('data must be an array');\n    return [];\n  }\n  const config = {\n    id: id || 'id',\n    parentId: parentId || 'parentId',\n    childrenList: children || 'children',\n  };\n\n  const childrenListMap = {};\n  const nodeIds = {};\n  const tree: any[] = [];\n\n  for (const d of data) {\n    const parentId = d[config.parentId];\n    if (childrenListMap[parentId] == null) {\n      childrenListMap[parentId] = [];\n    }\n    nodeIds[d[config.id]] = d;\n    childrenListMap[parentId].push(d);\n  }\n\n  for (const d of data) {\n    const parentId = d[config.parentId];\n    if (nodeIds[parentId] == null) {\n      tree.push(d);\n    }\n  }\n\n  for (const t of tree) {\n    adaptToChildrenList(t);\n  }\n\n  function adaptToChildrenList(o) {\n    if (childrenListMap[o[config.id]] !== null) {\n      o[config.childrenList] = childrenListMap[o[config.id]];\n    }\n    if (o[config.childrenList]) {\n      for (const c of o[config.childrenList]) {\n        adaptToChildrenList(c);\n      }\n    }\n  }\n\n  return tree;\n};\n\n/**\n * 构造树型结构数据\n * @param {*} data 数据源\n * @param {*} id id字段 默认 'id'\n * @param {*} parentId 父节点字段 默认 'parentId'\n * @param {*} children 孩子节点字段 默认 'children'\n * @param {*} rootId 根Id 默认 0\n */\n// @ts-ignore\nexport const handleTree2 = (data, id, parentId, children, rootId) => {\n  id = id || 'id';\n  parentId = parentId || 'parentId';\n  // children = children || 'children'\n  rootId =\n    rootId ||\n    Math.min(\n      ...data.map((item) => {\n        return item[parentId];\n      }),\n    ) ||\n    0;\n  // 对源数据深度克隆\n  const cloneData = JSON.parse(JSON.stringify(data));\n  // 循环所有项\n  const treeData = cloneData.filter((father) => {\n    const branchArr = cloneData.filter((child) => {\n      // 返回每一项的子级数组\n      return father[id] === child[parentId];\n    });\n    branchArr.length > 0 ? (father.children = branchArr) : '';\n    // 返回第一层\n    return father[parentId] === rootId;\n  });\n  return treeData !== '' ? treeData : data;\n};\n\n/**\n * 校验选中的节点，是否为指定 level\n * @param tree 要操作的树结构数据\n * @param nodeId 需要判断在什么层级的数据\n * @param level 检查的级别, 默认检查到二级\n * @return true 是；false 否\n */\nexport const checkSelectedNode = (tree: any[], nodeId: any, level = 2): boolean => {\n  if (typeof tree === 'undefined' || !Array.isArray(tree) || tree.length === 0) {\n    console.warn('tree must be an array');\n    return false;\n  }\n\n  // 校验是否是一级节点\n  if (tree.some((item) => item.id === nodeId)) {\n    return false;\n  }\n\n  // 递归计数\n  let count = 1;\n\n  // 深层次校验\n  function performAThoroughValidation(arr: any[]): boolean {\n    count += 1;\n    for (const item of arr) {\n      if (item.id === nodeId) {\n        return true;\n      } else if (typeof item.children !== 'undefined' && item.children.length !== 0) {\n        if (performAThoroughValidation(item.children)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  for (const item of tree) {\n    count = 1;\n    if (performAThoroughValidation(item.children)) {\n      // 找到后对比是否是期望的层级\n      if (count >= level) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n/**\n * 获取节点的完整结构\n * @param tree 树数据\n * @param nodeId 节点 id\n */\nexport const treeToString = (tree: any[], nodeId) => {\n  if (typeof tree === 'undefined' || !Array.isArray(tree) || tree.length === 0) {\n    console.warn('tree must be an array');\n    return '';\n  }\n  // 校验是否是一级节点\n  const node = tree.find((item) => item.id === nodeId);\n  if (typeof node !== 'undefined') {\n    return node.name;\n  }\n  let str = '';\n\n  function performAThoroughValidation(arr) {\n    for (const item of arr) {\n      if (item.id === nodeId) {\n        str += `/${item.name}`;\n        return true;\n      } else if (typeof item.children !== 'undefined' && item.children.length !== 0) {\n        str += `/${item.name}`;\n        if (performAThoroughValidation(item.children)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  for (const item of tree) {\n    str = `${item.name}`;\n    if (performAThoroughValidation(item.children)) {\n      break;\n    }\n  }\n  return str;\n};\n\n/**\n * 重新加载Tree数据\n */\nexport const reloadTreeData = (data, timestamp = 300) => {\n  const tdataList = data.value;\n  data.value = [];\n  setTimeout(() => {\n    data.value = tdataList;\n  }, timestamp);\n};\n"],"names":["defaultProps","handleTree","data","id","parentId","children","config","childrenListMap","nodeIds","tree","d","t","adaptToChildrenList","o","c","reloadTreeData","timestamp","tdataList"],"mappings":"AAWO,MAAMA,EAAe,CAC1B,SAAU,WACV,MAAO,OACP,MAAO,KACP,OAAQ,MACV,EAgNaC,EAAa,CAACC,EAAaC,EAAaC,EAAmBC,IAAsB,CAC5F,GAAI,CAAC,MAAM,QAAQH,CAAI,EACrB,eAAQ,KAAK,uBAAuB,EAC7B,GAET,MAAMI,EAAS,CACb,GAAIH,GAAM,KACV,SAAUC,GAAY,WACtB,aAAcC,GAAY,UAAA,EAGtBE,EAAkB,CAAA,EAClBC,EAAU,CAAA,EACVC,EAAc,CAAA,EAEpB,UAAWC,KAAKR,EAAM,CACdE,MAAAA,EAAWM,EAAEJ,EAAO,QAAQ,EAC9BC,EAAgBH,CAAQ,GAAK,OACfA,EAAAA,CAAQ,EAAI,IAE9BI,EAAQE,EAAEJ,EAAO,EAAE,CAAC,EAAII,EACRN,EAAAA,CAAQ,EAAE,KAAKM,CAAC,CAClC,CAEA,UAAWA,KAAKR,EAAM,CACdE,MAAAA,EAAWM,EAAEJ,EAAO,QAAQ,EAC9BE,EAAQJ,CAAQ,GAAK,MACvBK,EAAK,KAAKC,CAAC,CAEf,CAEA,UAAWC,KAAKF,EACdG,EAAoBD,CAAC,EAGvB,SAASC,EAAoBC,EAAG,CAI1B,GAHAN,EAAgBM,EAAEP,EAAO,EAAE,CAAC,IAAM,OACpCO,EAAEP,EAAO,YAAY,EAAIC,EAAgBM,EAAEP,EAAO,EAAE,CAAC,GAEnDO,EAAEP,EAAO,YAAY,EACvB,UAAWQ,KAAKD,EAAEP,EAAO,YAAY,EACnCM,EAAoBE,CAAC,CAG3B,CAEO,OAAAL,CACT,EAmIaM,EAAiB,CAACb,EAAMc,EAAY,MAAQ,CACvD,MAAMC,EAAYf,EAAK,MACvBA,EAAK,MAAQ,GACb,WAAW,IAAM,CACfA,EAAK,MAAQe,GACZD,CAAS,CACd"}